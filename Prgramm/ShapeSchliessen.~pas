unit ShapeSchliessen;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  ExtCtrls;

type
  TShapeSchliessen = class(TShape)
  private
    { Private-Deklarationen }
    FThemenfarbe1:TColor;
    FThemenfarbe2:TColor;
    FFenster:TForm;
    FInaktiv:boolean;
  protected
    { Protected-Deklarationen }
    procedure MouseMove(Shift: TShiftState; X,
      Y: Integer); override;
    procedure MouseDown(Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer); override;
  public
    { Public-Deklarationen }
    constructor Create(AOwner:TComponent);override;
    procedure Paint; override;
  published
    { Published-Deklarationen }
    property Left default 0;
    property OnMouseMove;
    property Themenfarbe1:Tcolor read FThemenfarbe1 write FThemenfarbe1 default clWhite;
    property Themenfarbe2:Tcolor read FThemenfarbe2 write FThemenfarbe2 default clWhite;
    property Fenster:TForm read FFenster write FFenster;
    property inaktiv:boolean read FInaktiv write FInaktiv default true;
  end;

procedure Register;

implementation

var dif:integer;

constructor TShapeSchliessen.Create(AOwner:TComponent);
begin
     inherited Create(AOwner);
     Left := 0;
     Top := 0;
     Width := Screen.Width+1;
     Height := Screen.Height div 30;

     Cursor := crHandpoint
end;

procedure TShapeSchliessen.Paint;
var Textposition:integer;
    Text:string;
begin
     inherited Paint;

     if inaktiv then
     begin
          Brush.Style := bsClear;
          Pen.Style := psClear;
     end else
     begin
          Brush.Style := bsSolid;
          Brush.Color := Themenfarbe2;

     with Canvas do
     begin
          Text := 'zum Schließen, Fenster nach unter ziehen';
          Font.Color := Themenfarbe1;
          Brush.Style := bsClear;
          Font.Charset := Ansi_Charset;
          Font.Name := 'permanent marker';
          Font.Size := (3*Height)div 5 ;
          Textposition := TextWidth(Text) div 2;
          TextOut((Screen.Width div 2)-Textposition,-5,Text);
     end;
     end;
end;

procedure TShapeSchliessen.MouseMove(Shift: TShiftState; X,
      Y: Integer);
begin
     inherited MouseMove(Shift,X,Y);

     if inaktiv then
     begin
          inaktiv := false;
          repaint;
     end;

     if Fenster.Align = alNone then
     begin
          Fenster.Top := Mouse.CursorPos.y - dif;
     end;
end;

procedure TShapeSchliessen.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
     inherited MouseDown(Button,Shift,X,Y);

     dif := Y;

     if Button = mbleft then                 // Wenn die linke Maustaste gedrückt wird,
     begin                                   // wird aus dem Vollbild "Normalbild" (ist aber nicht sichtbar,
          Fenster.Align := alNone;           // Dies muss aber geschehen, damit man das Fenster
     end;                                    // in Höhe und Breite verändern kann!


end;

procedure TShapeSchliessen.MouseUp(Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
     inherited MouseUp(Button,Shift,X,Y);

     if Mouse.CursorPos.y > Screen.Height div 2 then
     begin
          repeat;
                 Fenster.Top := Fenster.Top + 15;
                 sleep(1);
          until Fenster.Top > Screen.Height;
          Fenster.Close;
     end else
     begin
          if Fenster.Top > 10 then
          begin
               repeat;
                      Fenster.Top := Fenster.Top - 15;
                      sleep(1);
               until Fenster.Top < 0;
          end;
          Fenster.Align := alClient;
     end;
end;

procedure Register;
begin
  RegisterComponents('Übung', [TShapeSchliessen]);
end;

end.
